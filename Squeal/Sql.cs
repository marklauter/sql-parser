using Superpower;
using Superpower.Parsers;
using Superpower.Tokenizers;

namespace Squeal;

internal static class Sql
{
    public static readonly Tokenizer<SqlToken> Tokenizer = new TokenizerBuilder<SqlToken>()
        .Ignore(Span.WhiteSpace)
        .Match(Character.EqualTo('('), SqlToken.LParen)
        .Match(Character.EqualTo(')'), SqlToken.RParen)
        .Match(Character.EqualTo(','), SqlToken.Comma)
        .Match(Character.EqualTo('.'), SqlToken.Dot)
        .Match(Numerics.Integer, SqlToken.SignedNumber)
        .Match(Span.EqualToIgnoreCase("ABORT"), SqlToken.Abort, true)
        .Match(Span.EqualToIgnoreCase("ACTION"), SqlToken.Action, true)
        .Match(Span.EqualToIgnoreCase("ALWAYS"), SqlToken.Always, true)
        .Match(Span.EqualToIgnoreCase("AS"), SqlToken.As, true)
        .Match(Span.EqualToIgnoreCase("ASC"), SqlToken.Asc, true)
        .Match(Span.EqualToIgnoreCase("AUTOINCREMENT"), SqlToken.Autoincrement, true)
        .Match(Span.EqualToIgnoreCase("BETWEEN"), SqlToken.Between, true)
        .Match(Span.EqualToIgnoreCase("BLOB"), SqlToken.ColumnTypeBlob, true)
        .Match(Span.EqualToIgnoreCase("CASCADE"), SqlToken.Cascade, true)
        .Match(Span.EqualToIgnoreCase("CASE"), SqlToken.Case, true)
        .Match(Span.EqualToIgnoreCase("CAST"), SqlToken.Cast, true)
        .Match(Span.EqualToIgnoreCase("CHECK"), SqlToken.Check, true)
        .Match(Span.EqualToIgnoreCase("COLLATE"), SqlToken.Collate, true)
        .Match(Span.EqualToIgnoreCase("CONFLICT"), SqlToken.Conflict, true)
        .Match(Span.EqualToIgnoreCase("CONSTRAINT"), SqlToken.Constraint, true)
        .Match(Span.EqualToIgnoreCase("CREATE"), SqlToken.Create, true)
        .Match(Span.EqualToIgnoreCase("CURRENT_DATE"), SqlToken.CurrentDate, true)
        .Match(Span.EqualToIgnoreCase("CURRENT_TIME"), SqlToken.CurrentTime, true)
        .Match(Span.EqualToIgnoreCase("CURRENT_TIMESTAMP"), SqlToken.CurrentTimestamp, true)
        .Match(Span.EqualToIgnoreCase("DEFAULT"), SqlToken.Default, true)
        .Match(Span.EqualToIgnoreCase("DEFERRABLE"), SqlToken.Deferrable, true)
        .Match(Span.EqualToIgnoreCase("DEFERRED"), SqlToken.Deferred, true)
        .Match(Span.EqualToIgnoreCase("DELETE"), SqlToken.Delete, true)
        .Match(Span.EqualToIgnoreCase("DESC"), SqlToken.Desc, true)
        .Match(Span.EqualToIgnoreCase("DISTINCT"), SqlToken.Distinct, true)
        .Match(Span.EqualToIgnoreCase("ELSE"), SqlToken.Else, true)
        .Match(Span.EqualToIgnoreCase("END"), SqlToken.End, true)
        .Match(Span.EqualToIgnoreCase("EXISTS"), SqlToken.Exists, true)
        .Match(Span.EqualToIgnoreCase("FAIL"), SqlToken.Fail, true)
        .Match(Span.EqualToIgnoreCase("FALSE"), SqlToken.False)
        .Match(Span.EqualToIgnoreCase("FOREIGN"), SqlToken.Foreign, true)
        .Match(Span.EqualToIgnoreCase("FROM"), SqlToken.From, true)
        .Match(Span.EqualToIgnoreCase("GENERATED"), SqlToken.Generated, true)
        .Match(Span.EqualToIgnoreCase("IF"), SqlToken.If, true)
        .Match(Span.EqualToIgnoreCase("IGNORE"), SqlToken.Ignore, true)
        .Match(Span.EqualToIgnoreCase("IMMEDIATE"), SqlToken.Immediate, true)
        .Match(Span.EqualToIgnoreCase("IN"), SqlToken.In, true)
        .Match(Span.EqualToIgnoreCase("INDEX"), SqlToken.Index, true)
        .Match(Span.EqualToIgnoreCase("INITIALLY"), SqlToken.Initially, true)
        .Match(Span.EqualToIgnoreCase("INTEGER").Try().Or(Span.EqualToIgnoreCase("INT")), SqlToken.ColumnTypeInteger, true)
        .Match(Span.EqualToIgnoreCase("ISNULL"), SqlToken.IsNull, true)
        .Match(Span.EqualToIgnoreCase("KEY"), SqlToken.Key, true)
        .Match(Span.EqualToIgnoreCase("LIKE"), SqlToken.Like, true)
        .Match(Span.EqualToIgnoreCase("MATCH"), SqlToken.Match, true)
        .Match(Span.EqualToIgnoreCase("NO"), SqlToken.No, true)
        .Match(Span.EqualToIgnoreCase("NOT"), SqlToken.Not, true)
        .Match(Span.EqualToIgnoreCase("NOTNULL"), SqlToken.NotNull, true)
        .Match(Span.EqualToIgnoreCase("NULL"), SqlToken.Null, true)
        .Match(Span.EqualToIgnoreCase("NUMERIC").Try().Or(Span.EqualToIgnoreCase("NUM")), SqlToken.ColumnTypeNumeric, true)
        .Match(Span.EqualToIgnoreCase("ON"), SqlToken.On, true)
        .Match(Span.EqualToIgnoreCase("PRIMARY"), SqlToken.Primary, true)
        .Match(Span.EqualToIgnoreCase("REAL"), SqlToken.ColumnTypeReal, true)
        .Match(Span.EqualToIgnoreCase("REFERENCES"), SqlToken.References, true)
        .Match(Span.EqualToIgnoreCase("REPLACE"), SqlToken.Replace, true)
        .Match(Span.EqualToIgnoreCase("RESTRICT"), SqlToken.Restrict, true)
        .Match(Span.EqualToIgnoreCase("ROLLBACK"), SqlToken.Rollback, true)
        .Match(Span.EqualToIgnoreCase("SET"), SqlToken.Set, true)
        .Match(Span.EqualToIgnoreCase("STORED"), SqlToken.Stored, true)
        .Match(Span.EqualToIgnoreCase("TABLE"), SqlToken.Table, true)
        .Match(Span.EqualToIgnoreCase("TEMPORARY").Try().Or(Span.EqualToIgnoreCase("TEMP")), SqlToken.IsTemporary, true)
        .Match(Span.EqualToIgnoreCase("TEXT"), SqlToken.ColumnTypeText, true)
        .Match(Span.EqualToIgnoreCase("THEN"), SqlToken.Then, true)
        .Match(Span.EqualToIgnoreCase("TRIGGER"), SqlToken.Trigger, true)
        .Match(Span.EqualToIgnoreCase("TRUE"), SqlToken.True)
        .Match(Span.EqualToIgnoreCase("UNIQUE"), SqlToken.Unique, true)
        .Match(Span.EqualToIgnoreCase("VIEW"), SqlToken.View, true)
        .Match(Span.EqualToIgnoreCase("VIRTUAL"), SqlToken.Virtual, true)
        .Match(Span.EqualToIgnoreCase("WHEN"), SqlToken.When, true)
        .Match(Span.Regex(@"[a-zA-Z_][a-zA-Z0-9_]*"), SqlToken.Identifier, true)
        .Build();
}
